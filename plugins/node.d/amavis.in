#!@@PERL@@
# -*- perl -*-

=head1 NAME

amavis - plugin to monitor the amavis mail filter

=head1 APPLICABLE SYSTEMS

Hosts running amavis

=head1 CONFIGURATION

Configuration parameters for @@CONFDIR@@/amavis,
if you need to override the defaults below:

 [amavis]
  env.logdir  - Which logfile to use
  env.logfile - What file to read in logdir
  env.amavisd - Path to amavisd binary

=head2 DEFAULT CONFIGURATION

 [amavis]
  env.logdir  /var/log
  env.logfile mail.log

=head1 AUTHOR

Ported to Perl from the original shell script by Mark Meyer.

=head1 LICENSE

GPLv2

=head1 MAGIC MARKERS

=begin comment

These magic markers are used by munin-node-configure when installing
munin-node.

=end comment

 #%# family=auto
 #%# capabilities=autoconf

=cut

use strict;
use warnings;

use Munin::Plugin;

my $LOGDIR  = (defined($ENV{'logdir'})  ? $ENV{'logdir'}  : '/var/log');
my $LOGFILE = (defined($ENV{'logfile'}) ? $ENV{'logfile'} : 'mail.log');
my $AMAVISD = (defined($ENV{'amavisd'}) ? $ENV{'amavisd'} : 'amavisd');
my $logfile = "$LOGDIR/$LOGFILE";

if (defined($ARGV[0]) and $ARGV[0] eq "autoconf")
{
    `which $AMAVISD >/dev/null 2>/dev/null`;
    if (!$?)
    {
        my $s = autoconf_logfile($logfile);
        print "$s\n";
    }
    else
    {
        print "no (could not find amavis)\n";
    }
    exit 0;
}

my @state = restore_state();
my $pos   = shift @state;
my %mails = @state;

if (defined($ARGV[0]) and $ARGV[0] eq "config")
{
    print "graph_title Amavis throughput\n";
    print "graph_vlabel mails / \${graph_period}\n";
    print "graph_category mail\n";
    print "graph_scale no\n";
    print "graph_args --base 1000 -l 0\n";
    print "graph_period minute\n";
    print "graph_total total\n";
    foreach my $i (sort keys %mails)
    {
        print "$i.label $i\n";
        print "$i.type DERIVE\n";
        print "$i.draw AREASTACK\n";
        print "$i.info Number of $i mails evaluated by amavis\n";
    }
    exit 0;
}

if (!-r $logfile)
{
    foreach my $i (keys %mails)
    {
        print "$i.value U\n";
    }
    exit 1;
}

my $startsize = (stat $logfile)[7];
$pos               = $startsize unless defined($pos);
$mails{clean}      = 0          unless defined($mails{clean});
$mails{spam_maybe} = 0          unless defined($mails{spam_maybe});
$mails{spam_sure}  = 0          unless defined($mails{spam_sure});
$mails{virus}      = 0          unless defined($mails{virus});


if ($startsize < $pos)
{
    my $rotlogfile = rotlog($logfile);
    if (defined($rotlogfile))
    {
        parseLogfile($rotlogfile, $pos, (stat $rotlogfile)[7]);
    }
    $pos = 0;
}

$pos = parseLogfile($logfile, $pos, $startsize);

foreach my $i (keys %mails)
{
    print "$i.value $mails{$i}\n";
}

save_state($pos, %mails);

sub parseLogfile
{
    my ($fname, $start, $stop) = @_;

    my ($logfd, $reset) = tail_open($fname, $start);

    while (tell($logfd) < $stop)
    {
        my $line = <$logfd>;
        chomp($line);

        if ($line =~ /amavis/)
        {
            if ($line =~ /CLEAN/)
            {
                $mails{clean}++;
            }
            elsif ($line =~ /SPAMMY/)
            {
                $mails{spam_maybe}++;
            }
            elsif ($line =~ /SPAM/)
            {
                $mails{spam_sure}++;
            }
            elsif ($line =~ /INFECTED/)
            {
                $mails{virus}++;
            }
        }
    }
    return tail_close($logfd);
}

# vim:syntax=perl
